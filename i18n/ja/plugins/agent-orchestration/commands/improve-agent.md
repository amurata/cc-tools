# エージェントパフォーマンス最適化ワークフロー

> **[English](../../../plugins/agent-orchestration/commands/improve-agent.md)** | **日本語**

パフォーマンス分析、プロンプトエンジニアリング、継続的な反復を通じた既存エージェントの体系的改善。

[拡張思考: エージェント最適化には、パフォーマンスメトリクス、ユーザーフィードバック分析、高度なプロンプトエンジニアリング技術を組み合わせたデータ駆動アプローチが必要です。成功は、体系的な評価、的を絞った改善、本番環境の安全性のためのロールバック機能を備えた厳格なテストに依存します。]

## フェーズ 1: パフォーマンス分析とベースラインメトリクス

履歴データ収集のためにcontext-managerを使用したエージェントパフォーマンスの包括的分析。

### 1.1 パフォーマンスデータ収集
```
Use: context-manager
Command: analyze-agent-performance $ARGUMENTS --days 30
```

以下のメトリクスを収集：
- タスク完了率（成功 vs 失敗タスク）
- 応答精度と事実の正確性
- ツール使用効率（正しいツール、呼び出し頻度）
- 平均応答時間とトークン消費
- ユーザー満足度指標（修正、再試行）
- ハルシネーション発生とエラーパターン

### 1.2 ユーザーフィードバックパターン分析

ユーザーインタラクションの繰り返しパターンを特定：
- **修正パターン**: ユーザーが一貫して出力を変更する箇所
- **明確化リクエスト**: よくある曖昧な領域
- **タスク放棄**: ユーザーが諦めるポイント
- **フォローアップ質問**: 不完全な応答の指標
- **ポジティブフィードバック**: 保持すべき成功パターン

### 1.3 失敗モード分類

根本原因別に失敗を分類：
- **指示の誤解**: 役割またはタスクの混乱
- **出力形式エラー**: 構造または書式の問題
- **コンテキスト喪失**: 長い会話の劣化
- **ツールの誤用**: 不正確または非効率的なツール選択
- **制約違反**: 安全性またはビジネスルール違反
- **エッジケース処理**: 異常な入力シナリオ

### 1.4 ベースラインパフォーマンスレポート

定量的ベースラインメトリクスを生成：
```
パフォーマンスベースライン:
- タスク成功率: [X%]
- タスクあたり平均修正回数: [Y]
- ツールコール効率: [Z%]
- ユーザー満足度スコア: [1-10]
- 平均応答レイテンシ: [Xms]
- トークン効率比: [X:Y]
```

## フェーズ 2: プロンプトエンジニアリング改善

prompt-engineerエージェントを使用した高度なプロンプト最適化技術の適用。

### 2.1 Chain-of-Thought強化

構造化された推論パターンを実装：
```
Use: prompt-engineer
Technique: chain-of-thought-optimization
```

- 明示的な推論ステップを追加: 「ステップバイステップでアプローチしましょう...」
- 自己検証チェックポイントを含める: 「進める前に、...を検証してください」
- 複雑なタスクのための再帰的分解を実装
- デバッグのための推論トレース可視性を追加

### 2.2 Few-Shot例の最適化

成功したインタラクションから高品質な例をキュレート：
- 一般的なユースケースをカバーする**多様な例を選択**
- 以前に失敗した**エッジケースを含める**
- 説明付きで**ポジティブとネガティブの両方の例を示す**
- 単純なものから複雑なものへ**例を順序付け**
- 主要な意思決定ポイントで**例に注釈を付ける**

例の構造：
```
良い例:
入力: [ユーザーリクエスト]
推論: [ステップバイステップの思考プロセス]
出力: [成功した応答]
これが機能する理由: [主要な成功要因]

悪い例:
入力: [類似リクエスト]
出力: [失敗した応答]
これが失敗する理由: [特定の問題]
正しいアプローチ: [修正版]
```

### 2.3 役割定義の改善

エージェントのアイデンティティと能力を強化：
- **コア目的**: 明確な単一文のミッション
- **専門ドメイン**: 特定の知識領域
- **行動特性**: 個性とインタラクションスタイル
- **ツール習熟度**: 利用可能なツールと使用タイミング
- **制約**: エージェントが行うべきでないこと
- **成功基準**: タスク完了の測定方法

### 2.4 Constitutional AI統合

自己修正メカニズムを実装：
```
Constitutional原則:
1. 応答前に事実の正確性を検証
2. 潜在的なバイアスや有害コンテンツを自己チェック
3. 出力形式が要件に一致することを検証
4. 応答の完全性を確保
5. 以前の応答との一貫性を維持
```

批評と改訂のループを追加：
- 初期応答生成
- 原則に対する自己批評
- 問題が検出された場合の自動改訂
- 出力前の最終検証

### 2.5 出力形式チューニング

応答構造を最適化：
- 一般的なタスクのための**構造化テンプレート**
- 複雑性に基づく**動的書式設定**
- 詳細情報の**プログレッシブディスクロージャー**
- 可読性のための**Markdown最適化**
- シンタックスハイライト付き**コードブロック書式設定**
- データプレゼンテーションのための**テーブルとリスト生成**

## フェーズ 3: テストと検証

A/B比較を含む包括的テストフレームワーク。

### 3.1 テストスイート開発

代表的なテストシナリオを作成：
```
テストカテゴリ:
1. ゴールデンパスシナリオ（一般的な成功ケース）
2. 以前に失敗したタスク（リグレッションテスト）
3. エッジケースとコーナーシナリオ
4. ストレステスト（複雑なマルチステップタスク）
5. 敵対的入力（潜在的な破壊ポイント）
6. クロスドメインタスク（能力の組み合わせ）
```

### 3.2 A/Bテストフレームワーク

元のエージェントと改善されたエージェントを比較：
```
Use: parallel-test-runner
Config:
  - Agent A: オリジナルバージョン
  - Agent B: 改善バージョン
  - Test set: 100の代表的タスク
  - Metrics: 成功率、速度、トークン使用
  - Evaluation: ブラインドヒューマンレビュー + 自動スコアリング
```

統計的有意性テスト：
- 最小サンプルサイズ: バリアントあたり100タスク
- 信頼水準: 95%（p < 0.05）
- 効果量計算（Cohen's d）
- 将来のテストのための検出力分析

### 3.3 評価メトリクス

包括的スコアリングフレームワーク：

**タスクレベルメトリクス:**
- 完了率（バイナリ成功/失敗）
- 正確性スコア（0-100%精度）
- 効率スコア（実行ステップ vs 最適）
- ツール使用の適切性
- 応答の関連性と完全性

**品質メトリクス:**
- ハルシネーション率（応答あたりの事実エラー）
- 一貫性スコア（以前の応答との整合性）
- 形式準拠（指定された構造との一致）
- 安全性スコア（制約遵守）
- ユーザー満足度予測

**パフォーマンスメトリクス:**
- 応答レイテンシ（最初のトークンまでの時間）
- 総生成時間
- トークン消費（入力 + 出力）
- タスクあたりコスト（API使用料）
- メモリ/コンテキスト効率

### 3.4 ヒューマン評価プロトコル

構造化されたヒューマンレビュープロセス：
- ブラインド評価（評価者はバージョンを知らない）
- 明確な基準を持つ標準化されたルーブリック
- サンプルあたり複数の評価者（評価者間信頼性）
- 定性的フィードバック収集
- 選好ランキング（A vs B比較）

## フェーズ 4: バージョン管理とデプロイメント

監視とロールバック機能を備えた安全なロールアウト。

### 4.1 バージョン管理

体系的なバージョニング戦略：
```
バージョン形式: agent-name-v[MAJOR].[MINOR].[PATCH]
例: customer-support-v2.3.1

MAJOR: 重要な機能変更
MINOR: プロンプト改善、新しい例
PATCH: バグ修正、軽微な調整
```

バージョン履歴を維持：
- Gitベースのプロンプトストレージ
- 改善詳細を含む変更ログ
- バージョンごとのパフォーマンスメトリクス
- 文書化されたロールバック手順

### 4.2 段階的ロールアウト

プログレッシブデプロイメント戦略：
1. **アルファテスト**: 内部チーム検証（5%トラフィック）
2. **ベータテスト**: 選択されたユーザー（20%トラフィック）
3. **カナリアリリース**: 段階的増加（20% → 50% → 100%）
4. **完全デプロイメント**: 成功基準達成後
5. **監視期間**: 7日間の観察ウィンドウ

### 4.3 ロールバック手順

迅速なリカバリメカニズム：
```
ロールバックトリガー:
- 成功率がベースラインから>10%低下
- クリティカルエラーが>5%増加
- ユーザークレームの急増
- タスクあたりコストが>20%増加
- 安全性違反の検出

ロールバックプロセス:
1. 監視を通じて問題を検出
2. 直ちにチームに警告
3. 以前の安定バージョンに切り替え
4. 根本原因を分析
5. 再試行前に修正と再テスト
```

### 4.4 継続的監視

リアルタイムパフォーマンス追跡：
- 主要メトリクスのダッシュボード
- 異常検出アラート
- ユーザーフィードバック収集
- 自動化されたリグレッションテスト
- 週次パフォーマンスレポート

## 成功基準

エージェント改善が成功する条件：
- タスク成功率が≥15%改善
- ユーザー修正が≥25%減少
- 安全性違反の増加なし
- 応答時間がベースラインの10%以内に維持
- タスクあたりコストが>5%増加しない
- ポジティブなユーザーフィードバックが増加

## デプロイメント後レビュー

本番環境使用30日後：
1. 蓄積されたパフォーマンスデータを分析
2. ベースラインとターゲットと比較
3. 新しい改善機会を特定
4. 学んだ教訓を文書化
5. 次の最適化サイクルを計画

## 継続的改善サイクル

定期的な改善ケイデンスを確立：
- **週次**: メトリクスを監視し、フィードバックを収集
- **月次**: パターンを分析し、改善を計画
- **四半期**: 新機能を含むメジャーバージョン更新
- **年次**: 戦略的レビューとアーキテクチャ更新

覚えておいてください: エージェント最適化は反復プロセスです。各サイクルは以前の学習に基づいて構築され、安定性と安全性を維持しながら徐々にパフォーマンスを向上させます。
