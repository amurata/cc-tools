> **[English](../../../plugins/multi-platform-apps/commands/multi-platform.md)** | **日本語**

# マルチプラットフォーム機能開発ワークフロー

APIファーストアーキテクチャと並列実装戦略を使用して、Web、モバイル、デスクトッププラットフォーム全体で同じ機能を一貫して構築およびデプロイします。

[Extended thinking: このワークフローは、プラットフォーム固有の最適化を維持しながら、プラットフォーム全体で機能パリティを確保するために、複数の専門エージェントをオーケストレーションします。調整戦略は、定期的な同期ポイントを持つ共有コントラクトと並列開発を強調します。APIコントラクトとデータモデルを事前に確立することで、チームは一貫性を確保しながら独立して作業できます。このワークフローの利点には、市場投入までの時間の短縮、統合問題の削減、保守可能なクロスプラットフォームコードベースが含まれます。]

## フェーズ1: アーキテクチャとAPI設計（順次）

### 1. 機能要求とAPIコントラクトの定義
- subagent_type="backend-architect"でTaskツールを使用
- プロンプト: "機能のAPIコントラクトを設計してください: $ARGUMENTS。以下を含むOpenAPI 3.1仕様を作成してください：
  - 適切なHTTPメソッドとステータスコードを持つRESTfulエンドポイント
  - 複雑なデータクエリのための該当する場合はGraphQLスキーマ
  - リアルタイム機能のためのWebSocketイベント
  - 検証ルールを持つリクエスト/レスポンススキーマ
  - 認証と認可の要件
  - レート制限とキャッシング戦略
  - エラーレスポンスフォーマットとコード
  すべてのプラットフォームが使用する共有データモデルを定義してください。"
- 期待される出力: 完全なAPI仕様、データモデル、統合ガイドライン

### 2. デザインシステムとUI/UXの一貫性
- subagent_type="ui-ux-designer"でTaskツールを使用
- プロンプト: "API仕様を使用して機能のクロスプラットフォームデザインシステムを作成してください: [前の出力]。以下を含めてください：
  - 各プラットフォームのコンポーネント仕様（Material Design、iOS HIG、Fluent）
  - Webのためのレスポンシブレイアウト（モバイルファーストアプローチ）
  - iOSとAndroidのためのネイティブパターン（SwiftUIとMaterial You）
  - デスクトップ固有の考慮事項（キーボードショートカット、ウィンドウ管理）
  - アクセシビリティ要件（WCAG 2.2 Level AA）
  - ダーク/ライトテーマ仕様
  - アニメーションとトランジションのガイドライン"
- 前のコンテキスト: APIエンドポイント、データ構造、認証フロー
- 期待される出力: デザインシステムドキュメント、コンポーネントライブラリ仕様、プラットフォームガイドライン

### 3. 共有ビジネスロジックアーキテクチャ
- subagent_type="comprehensive-review::architect-review"でTaskツールを使用
- プロンプト: "クロスプラットフォーム機能の共有ビジネスロジックアーキテクチャを設計してください。以下を定義してください：
  - コアドメインモデルとエンティティ（プラットフォームに依存しない）
  - ビジネスルールと検証ロジック
  - 状態管理パターン（MVI/Redux/BLoC）
  - キャッシングとオフライン戦略
  - エラーハンドリングとリトライポリシー
  - プラットフォーム固有のアダプターパターン
  モバイル用のKotlin MultiplatformまたはWeb/デスクトップ共有用のTypeScriptを検討してください。"
- 前のコンテキスト: APIコントラクト、データモデル、UI要件
- 期待される出力: 共有コードアーキテクチャ、プラットフォーム抽象化レイヤー、実装ガイド

## フェーズ2: 並列プラットフォーム実装

### 4a. Web実装（React/Next.js）
- subagent_type="frontend-developer"でTaskツールを使用
- プロンプト: "以下を使用して機能のWeb版を実装してください：
  - Next.js 14+ App Routerを使用したReact 18+
  - 型安全性のためのTypeScript
  - API統合のためのTanStack Query: [API仕様]
  - 状態管理のためのZustand/Redux Toolkit
  - デザインシステムを使用したTailwind CSS: [デザイン仕様]
  - プログレッシブWebアプリ機能
  - 適切な場合のSSR/SSG最適化
  - Webバイタル最適化（LCP < 2.5s、FID < 100ms）
  共有ビジネスロジックに従ってください: [アーキテクチャドキュメント]"
- 前のコンテキスト: APIコントラクト、デザインシステム、共有ロジックパターン
- 期待される出力: テスト付きの完全なWeb実装

### 4b. iOS実装（SwiftUI）
- subagent_type="ios-developer"でTaskツールを使用
- プロンプト: "以下を使用してiOS版を実装してください：
  - iOS 17+機能を使用したSwiftUI
  - async/awaitを使用したSwift 5.9+
  - API用のCombineを使用したURLSession: [API仕様]
  - 永続化のためのCore Data/SwiftData
  - デザインシステムコンプライアンス: [iOS HIG仕様]
  - 該当する場合のウィジェット拡張
  - プラットフォーム固有の機能（Face ID、Haptics、Live Activities）
  - テスト可能なMVVMアーキテクチャ
  共有パターンに従ってください: [アーキテクチャドキュメント]"
- 前のコンテキスト: APIコントラクト、iOSデザインガイドライン、共有モデル
- 期待される出力: ユニット/UIテスト付きのネイティブiOS実装

### 4c. Android実装（Kotlin/Compose）
- subagent_type="mobile-developer"でTaskツールを使用
- プロンプト: "以下を使用してAndroid版を実装してください：
  - Material 3を使用したJetpack Compose
  - KotlinコルーチンとFlow
  - API用のRetrofit/Ktor: [API仕様]
  - ローカルストレージ用のRoomデータベース
  - 依存性注入のためのHilt
  - Material Youダイナミックテーマ: [デザイン仕様]
  - プラットフォーム機能（生体認証、ウィジェット）
  - MVIパターンを使用したクリーンアーキテクチャ
  共有ロジックに従ってください: [アーキテクチャドキュメント]"
- 前のコンテキスト: APIコントラクト、Material Design仕様、共有パターン
- 期待される出力: テスト付きのネイティブAndroid実装

### 4d. デスクトップ実装（オプション - Electron/Tauri）
- subagent_type="frontend-mobile-development::frontend-developer"でTaskツールを使用
- プロンプト: "以下を使用してTauri 2.0またはElectronでデスクトップ版を実装してください：
  - 可能な限り共有Webコードベース
  - ネイティブOS統合（システムトレイ、通知）
  - 必要に応じたファイルシステムアクセス
  - 自動更新機能
  - コード署名とノータリゼーションの設定
  - キーボードショートカットとメニューバー
  - 該当する場合のマルチウィンドウサポート
  Webコンポーネントを再利用してください: [Web実装]"
- 前のコンテキスト: Web実装、デスクトップ固有の要件
- 期待される出力: プラットフォームパッケージ付きのデスクトップアプリケーション

## フェーズ3: 統合と検証

### 5. APIドキュメントとテスト
- subagent_type="documentation-generation::api-documenter"でTaskツールを使用
- プロンプト: "以下を含む包括的なAPIドキュメントを作成してください：
  - インタラクティブなOpenAPI/Swaggerドキュメント
  - プラットフォーム固有の統合ガイド
  - 各プラットフォームのSDK例
  - 認証フロー図
  - レート制限とクォータ情報
  - Postman/Insomniaコレクション
  - WebSocket接続例
  - エラーハンドリングのベストプラクティス
  - APIバージョニング戦略
  プラットフォーム実装ですべてのエンドポイントをテストしてください。"
- 前のコンテキスト: 実装されたプラットフォーム、API使用パターン
- 期待される出力: 完全なAPIドキュメントポータル、テスト結果

### 6. クロスプラットフォームテストと機能パリティ
- subagent_type="unit-testing::test-automator"でTaskツールを使用
- プロンプト: "すべてのプラットフォーム全体で機能パリティを検証してください：
  - 機能テストマトリクス（機能が同一に動作）
  - UI一貫性検証（デザインシステムに従う）
  - プラットフォームごとのパフォーマンスベンチマーク
  - アクセシビリティテスト（プラットフォーム固有のツール）
  - ネットワークレジリエンステスト（オフライン、低速接続）
  - データ同期検証
  - プラットフォーム固有のエッジケース
  - エンドツーエンドユーザージャーニーテスト
  プラットフォームの不一致を含むテストレポートを作成してください。"
- 前のコンテキスト: すべてのプラットフォーム実装、APIドキュメント
- 期待される出力: テストレポート、パリティマトリクス、パフォーマンスメトリクス

### 7. プラットフォーム固有の最適化
- subagent_type="application-performance::performance-engineer"でTaskツールを使用
- プロンプト: "各プラットフォーム実装を最適化してください：
  - Web: バンドルサイズ、遅延読み込み、CDNセットアップ、SEO
  - iOS: アプリサイズ、起動時間、メモリ使用量、バッテリー
  - Android: APKサイズ、起動時間、フレームレート、バッテリー
  - デスクトップ: バイナリサイズ、リソース使用量、起動時間
  - API: レスポンス時間、キャッシング、圧縮
  プラットフォームの強みを活用しながら機能パリティを維持してください。
  最適化技術とトレードオフをドキュメント化してください。"
- 前のコンテキスト: テスト結果、パフォーマンスメトリクス
- 期待される出力: 最適化された実装、パフォーマンス改善

## 設定オプション

- **--platforms**: ターゲットプラットフォームを指定（web,ios,android,desktop）
- **--api-first**: UI実装の前にAPIを生成（デフォルト: true）
- **--shared-code**: Kotlin Multiplatformまたは類似のものを使用（デフォルト: 評価）
- **--design-system**: 既存のものを使用するか新規作成（デフォルト: 作成）
- **--testing-strategy**: ユニット、統合、e2e（デフォルト: すべて）

## 成功基準

- 実装前にAPIコントラクトが定義され検証されている
- すべてのプラットフォームが<5%の差異で機能パリティを達成している
- パフォーマンスメトリクスがプラットフォーム固有の基準を満たしている
- アクセシビリティ基準を満たしている（WCAG 2.2 AA最低）
- クロスプラットフォームテストが一貫した動作を示している
- すべてのプラットフォームのドキュメントが完全である
- 該当する場合、プラットフォーム間でコードの再利用が>40%
- ユーザーエクスペリエンスが各プラットフォームの慣習に最適化されている

## プラットフォーム固有の考慮事項

**Web**: PWA機能、SEO最適化、ブラウザ互換性
**iOS**: App Storeガイドライン、TestFlight配布、iOS固有の機能
**Android**: Play Store要件、Android App Bundles、デバイスの断片化
**デスクトップ**: コード署名、自動更新、OS固有のインストーラー

初期機能仕様: $ARGUMENTS
