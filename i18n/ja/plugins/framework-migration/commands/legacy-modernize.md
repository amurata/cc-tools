> **[English](../../../../../plugins/framework-migration/commands/legacy-modernize.md)** | **日本語**

# レガシーコードモダナイゼーションワークフロー

ストラングラーフィグパターンを使用して包括的なレガシーシステムのモダナイゼーションを orchestrate し、エキスパートエージェントの調整を通じて継続的なビジネス運用を維持しながら、古いコンポーネントの段階的な置き換えを可能にします。

[拡張思考: 熱帯のイチジクの木がホストを徐々に包み込み置き換えることにちなんで名付けられたストラングラーフィグパターンは、リスク管理されたレガシーモダナイゼーションのゴールドスタンダードを表します。このワークフローは、新しい機能がレガシーコンポーネントを徐々に置き換える体系的なアプローチを実装し、移行中に両方のシステムが共存できるようにします。評価、テスト、セキュリティ、実装のための専門エージェントを orchestrate することで、各移行フェーズが進行前に検証されることを保証し、混乱を最小限に抑えながらモダナイゼーションの速度を最大化します。]

## フェーズ1: レガシー評価とリスク分析

### 1. 包括的レガシーシステム分析
- Task toolをsubagent_type="legacy-modernizer"で使用
- プロンプト: "$ARGUMENTSのレガシーコードベースを分析してください。古い依存関係、非推奨API、セキュリティ脆弱性、パフォーマンスボトルネック、アーキテクチャアンチパターンを含む技術的負債のインベントリを文書化します。コンポーネント複雑度スコア（1-10）、依存関係マッピング、データベース結合分析を含むモダナイゼーション準備レポートを生成します。クイックウィン対複雑なリファクタリング対象を特定します。"
- 期待される出力: リスクマトリックスとモダナイゼーション優先順位を含む詳細な評価レポート

### 2. 依存関係と統合マッピング
- Task toolをsubagent_type="architect-review"で使用
- プロンプト: "レガシー評価レポートに基づいて、内部モジュール依存関係、外部サービス統合、共有データベーススキーマ、システム間データフローを示す包括的な依存関係グラフを作成してください。移行中にファサードパターンまたはアダプタレイヤーが必要となる統合ポイントを特定します。解決が必要な循環依存関係と密結合をハイライトします。"
- 前のコンテキスト: レガシー評価レポート、コンポーネント複雑度スコア
- 期待される出力: ビジュアル依存関係マップと統合ポイントカタログ

### 3. ビジネス影響とリスク評価
- Task toolをsubagent_type="business-analytics::business-analyst"で使用
- プロンプト: "特定された各コンポーネントのモダナイゼーションのビジネス影響を評価してください。ビジネスクリティカリティ（収益影響）、ユーザートラフィックパターン、データの機密性、規制要件、フォールバック複雑性を考慮したリスク評価マトリックスを作成します。重み付けスコアリングシステムを使用してコンポーネントを優先順位付け: (ビジネス価値 × 0.4) + (技術リスク × 0.3) + (クイックウィン可能性 × 0.3)。各コンポーネントのロールバック戦略を定義します。"
- 前のコンテキスト: コンポーネントインベントリ、依存関係マッピング
- 期待される出力: リスク軽減戦略を含む優先順位付け移行ロードマップ

## フェーズ2: テストカバレッジの確立

### 1. レガシーコードテストカバレッジ分析
- Task toolをsubagent_type="unit-testing::test-automator"で使用
- プロンプト: "$ARGUMENTSのレガシーコンポーネントの既存テストカバレッジを分析してください。カバレッジツールを使用して、テストされていないコードパス、欠落している統合テスト、ない end-to-end シナリオを特定します。40%未満のカバレッジのコンポーネントには、機能を変更せずに現在の動作をキャプチャする特性テストを生成します。安全なリファクタリングのためのテストハーネスを作成します。"
- 期待される出力: テストカバレッジレポートと特性テストスイート

### 2. コントラクトテスト実装
- Task toolをsubagent_type="unit-testing::test-automator"で使用
- プロンプト: "依存関係マッピングで特定されたすべての統合ポイントのコントラクトテストを実装してください。API、メッセージキューインタラクション、データベーススキーマのコンシューマー駆動コントラクトを作成します。CI/CDパイプラインでコントラクト検証をセットアップします。モダナイズされたコンポーネントがSLAを維持することを検証するためのレスポンスタイムとスループットのパフォーマンスベースラインを生成します。"
- 前のコンテキスト: 統合ポイントカタログ、既存テストカバレッジ
- 期待される出力: パフォーマンスベースラインを含むコントラクトテストスイート

### 3. テストデータ管理戦略
- Task toolをsubagent_type="data-engineering::data-engineer"で使用
- プロンプト: "並列システム操作のためのテストデータ管理戦略を設計してください。エッジケースのデータ生成スクリプトを作成し、機密情報のデータマスキングを実装し、テストデータベース更新手順を確立します。移行中のレガシーとモダナイズされたコンポーネント間のデータ一貫性の監視をセットアップします。"
- 前のコンテキスト: データベーススキーマ、テスト要件
- 期待される出力: テストデータパイプラインと一貫性監視

## フェーズ3: 段階的移行実装

### 1. ストラングラーフィグインフラストラクチャセットアップ
- Task toolをsubagent_type="backend-development::backend-architect"で使用
- プロンプト: "トラフィックルーティングのためのAPIゲートウェイを含むストラングラーフィグインフラストラクチャを実装してください。環境変数または機能管理サービスを使用した段階的ロールアウトのための機能フラグを設定します。URLパターン、ヘッダー、またはユーザーセグメントに基づくリクエストルーティングルールを含むプロキシレイヤーをセットアップします。レジリエンスのためのサーキットブレーカーとフォールバックメカニズムを実装します。デュアルシステム監視のための可観測性ダッシュボードを作成します。"
- 期待される出力: APIゲートウェイ設定、機能フラグシステム、監視ダッシュボード

### 2. コンポーネントモダナイゼーション - 第一波
- Task toolをsubagent_type="python-development::python-pro"または"golang-pro"で使用（ターゲットスタックに基づく）
- プロンプト: "第一波コンポーネント（評価で特定されたクイックウィン）をモダナイズしてください。各コンポーネントについて: レガシーコードからビジネスロジックを抽出し、モダンパターン（依存性注入、SOLID原則）を使用して実装し、アダプタパターンを通じて後方互換性を確保し、イベントソーシングまたはデュアルライトでデータ一貫性を維持します。12ファクターアプリ原則に従ってください。モダナイズするコンポーネント: [優先順位付けロードマップからのリスト]"
- 前のコンテキスト: 特性テスト、コントラクトテスト、インフラストラクチャセットアップ
- 期待される出力: アダプタを含むモダナイズされたコンポーネント

### 3. セキュリティ強化
- Task toolをsubagent_type="security-scanning::security-auditor"で使用
- プロンプト: "モダナイズされたコンポーネントのセキュリティ脆弱性を監査してください。OAuth 2.0/JWT認証、ロールベースアクセス制御、入力検証とサニタイゼーション、SQLインジェクション防止、XSS保護、シークレット管理を含むセキュリティ改善を実装します。OWASP top 10コンプライアンスを検証します。セキュリティヘッダーを設定し、レート制限を実装します。"
- 前のコンテキスト: モダナイズされたコンポーネントコード
- 期待される出力: セキュリティ監査レポートと強化されたコンポーネント

## フェーズ4: パフォーマンス検証と最適化

### 1. パフォーマンステストと最適化
- Task toolをsubagent_type="application-performance::performance-engineer"で使用
- プロンプト: "レガシー対モダナイズされたコンポーネントを比較するパフォーマンステストを実施してください。本番トラフィックパターンをシミュレートする負荷テストを実行し、レスポンスタイム、スループット、リソース使用率を測定します。パフォーマンスリグレッションを特定し、最適化: インデックス化を伴うデータベースクエリ、キャッシング戦略（Redis/Memcached）、接続プーリング、該当する場合は非同期処理。SLA要件に対して検証します。"
- 前のコンテキスト: パフォーマンスベースライン、モダナイズされたコンポーネント
- 期待される出力: パフォーマンステスト結果と最適化推奨事項

### 2. 段階的ロールアウトと監視
- Task toolをsubagent_type="deployment-strategies::deployment-engineer"で使用
- プロンプト: "機能フラグを使用した段階的ロールアウト戦略を実装してください。モダナイズされたコンポーネントへの5%トラフィックから開始し、エラー率、レイテンシー、ビジネスメトリクスを監視します。自動ロールバックトリガーを定義: エラー率>1%、レイテンシー>2xベースライン、またはビジネスメトリクス劣化。トラフィックシフトのランブックを作成: 5% → 25% → 50% → 100% を24時間観察期間で。"
- 前のコンテキスト: 機能フラグ設定、監視ダッシュボード
- 期待される出力: 自動セーフガードを含むロールアウト計画

## フェーズ5: 移行完了とドキュメンテーション

### 1. レガシーコンポーネント廃止
- Task toolをsubagent_type="legacy-modernizer"で使用
- プロンプト: "置き換えられたレガシーコンポーネントの安全な廃止を計画してください。トラフィック分析を通じて残りの依存関係がないことを検証（最低30日間0%トラフィック）。元の機能のドキュメンテーションとともにレガシーコードをアーカイブします。レガシービルドを削除するためにCI/CDパイプラインを更新します。未使用のデータベーステーブルをクリーンアップし、非推奨APIエンドポイントを削除します。保持されたレガシーコンポーネントをサンセットタイムラインとともに文書化します。"
- 前のコンテキスト: トラフィックルーティングデータ、モダナイゼーションステータス
- 期待される出力: 廃止チェックリストとタイムライン

### 2. ドキュメンテーションと知識移転
- Task toolをsubagent_type="documentation-generation::docs-architect"で使用
- プロンプト: "アーキテクチャ図（ビフォー/アフター）、移行ガイド付きAPIドキュメンテーション、デュアルシステム操作のランブック、一般的な問題のトラブルシューティングガイド、学んだ教訓レポートを含む包括的なモダナイゼーションドキュメンテーションを作成してください。モダナイズされたシステムの開発者オンボーディングガイドを生成します。移行中に行われた技術的決定とトレードオフを文書化します。"
- 前のコンテキスト: すべての移行成果物と決定
- 期待される出力: 完全なモダナイゼーションドキュメンテーションパッケージ

## 設定オプション

- **--parallel-systems**: 両方のシステムを無期限に実行し続ける（段階的移行用）
- **--big-bang**: 検証後の完全カットオーバー（高リスク、より速い完了）
- **--by-feature**: 技術コンポーネントではなく完全な機能を移行
- **--database-first**: アプリケーション層の前にデータベースモダナイゼーションを優先
- **--api-first**: レガシーバックエンドを維持しながらAPI層をモダナイズ

## 成功基準

- すべての高優先度コンポーネントが>80%テストカバレッジでモダナイズ
- 移行中の計画外ダウンタイムゼロ
- パフォーマンスメトリクスが維持または改善（P95レイテンシーがベースラインの110%以内）
- セキュリティ脆弱性が>90%削減
- 技術的負債スコアが>60%改善
- ロールバックなしで移行後30日間の成功運用
- 1週間未満で新規開発者オンボーディングを可能にする完全なドキュメンテーション

対象: $ARGUMENTS
