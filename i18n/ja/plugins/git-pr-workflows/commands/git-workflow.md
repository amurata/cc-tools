> **[English](../../../../plugins/git-pr-workflows/commands/git-workflow.md)** | **日本語**

# マルチエージェントオーケストレーションによる完全Gitワークフロー

品質保証、テスト、デプロイ準備のための専門エージェントを活用して、コードレビューからPR作成までの包括的なgitワークフローをオーケストレーション。このワークフローは、Conventional Commits、自動テスト、構造化PR作成を含むモダンgitベストプラクティスを実装します。

[拡張思考: このワークフローは、コミットが行われる前にコード品質を確保するために複数の専門エージェントを調整します。code-reviewerエージェントが初期品質チェックを実行し、test-automatorがすべてのテストが合格することを確認し、deployment-engineerが本番環境対応を検証します。コンテキスト受け渡しによってこれらのエージェントを順次オーケストレーションすることで、壊れたコードがリポジトリに入るのを防ぎながら高い速度を維持します。ワークフローは、異なるチームのニーズに応じた設定可能なオプションにより、トランクベースとフィーチャーブランチの両方の戦略をサポートします。]

## 設定

**ターゲットブランチ**: $ARGUMENTS（指定がない場合は'main'をデフォルト）

**サポートされるフラグ**:
- `--skip-tests`: 自動テスト実行をスキップ（注意して使用）
- `--draft-pr`: 作業中のためにPRをドラフトとして作成
- `--no-push`: すべてのチェックを実行するがリモートにプッシュしない
- `--squash`: プッシュ前にコミットをスカッシュ
- `--conventional`: Conventional Commits形式を厳密に強制
- `--trunk-based`: トランクベース開発ワークフローを使用
- `--feature-branch`: フィーチャーブランチワークフローを使用（デフォルト）

## フェーズ1: コミット前レビューと分析

### 1. コード品質評価
- subagent_type="code-reviewer"でTaskツールを使用
- プロンプト: "すべてのコミットされていない変更をコード品質の問題についてレビュー。チェック項目: 1) コードスタイル違反、2) セキュリティ脆弱性、3) パフォーマンスの懸念、4) エラー処理の欠如、5) 不完全な実装。重大度レベル（critical/high/medium/low）を含む詳細なレポートを生成し、行ごとの具体的なフィードバックを提供。出力形式: {issues: [], summary: {critical: 0, high: 0, medium: 0, low: 0}, recommendations: []}のJSON"
- 期待される出力: 次のフェーズのための構造化コードレビューレポート

### 2. 依存関係と破壊的変更分析
- subagent_type="code-reviewer"でTaskツールを使用
- プロンプト: "変更を次について分析: 1) 新しい依存関係またはバージョン変更、2) 破壊的API変更、3) データベーススキーマ変更、4) 設定変更、5) 後方互換性の問題。前回のレビューのコンテキスト: [問題の要約を挿入]。マイグレーションスクリプトまたはドキュメント更新が必要な変更を特定。"
- 前回からのコンテキスト: 破壊的変更を示す可能性のあるコード品質の問題
- 期待される出力: 破壊的変更評価とマイグレーション要件

## フェーズ2: テストと検証

### 1. テスト実行とカバレッジ
- subagent_type="unit-testing::test-automator"でTaskツールを使用
- プロンプト: "変更されたコードのすべてのテストスイートを実行。実行: 1) ユニットテスト、2) 統合テスト、3) 該当する場合はエンドツーエンドテスト。カバレッジレポートを生成し、テストされていないコードパスを特定。レビュー問題に基づいて: [critical/high問題を挿入]、テストが問題領域をカバーすることを確認。テスト結果を形式で提供: {passed: [], failed: [], skipped: [], coverage: {statements: %, branches: %, functions: %, lines: %}, untested_critical_paths: []}"
- 前回からのコンテキスト: テストカバレッジが必要な重大コードレビュー問題
- 期待される出力: 完全なテスト結果とカバレッジメトリクス

### 2. テスト推奨事項とギャップ分析
- subagent_type="unit-testing::test-automator"でTaskツールを使用
- プロンプト: "テスト結果[要約を挿入]とコード変更に基づいて、以下を特定: 1) 欠落しているテストシナリオ、2) カバーされていないエッジケース、3) 検証が必要な統合ポイント、4) 必要なパフォーマンスベンチマーク。リスクによって優先順位付けされたテスト実装推奨事項を生成。特定された破壊的変更を考慮: [破壊的変更を挿入]。"
- 前回からのコンテキスト: テスト結果、破壊的変更、テストされていないパス
- 期待される出力: 必要な追加テストの優先順位付けリスト

## フェーズ3: コミットメッセージ生成

### 1. 変更分析とカテゴリ化
- subagent_type="code-reviewer"でTaskツールを使用
- プロンプト: "すべての変更を分析し、Conventional Commits仕様に従ってカテゴリ化。主要な変更タイプ（feat/fix/docs/style/refactor/perf/test/build/ci/chore/revert）とスコープを特定。変更: [ファイルリストと要約を挿入]について、これが単一のコミットか複数のアトミックコミットかを判断。テスト結果を考慮: [テスト要約を挿入]。"
- 前回からのコンテキスト: テスト結果、コードレビュー要約
- 期待される出力: コミット構造推奨事項

### 2. Conventional Commitメッセージ作成
- subagent_type="llm-application-dev::prompt-engineer"でTaskツールを使用
- プロンプト: "カテゴリ化に基づいてConventional Commits形式メッセージを作成: [カテゴリ化を挿入]。形式: <type>(<scope>): <subject> 空行の後に<body>で何をなぜ説明（方法ではない）、次に<footer>で該当する場合はBREAKING CHANGE:を含む。含める: 1) 明確な件名行（最大50文字）、2) 理由を説明する詳細な本文、3) 問題/チケットへの参照、4) 該当する場合は共著者。影響を考慮: [該当する場合は破壊的変更を挿入]。"
- 前回からのコンテキスト: 変更のカテゴリ化、破壊的変更
- 期待される出力: 適切にフォーマットされたコミットメッセージ

## フェーズ4: ブランチ戦略とプッシュ準備

### 1. ブランチ管理
- subagent_type="cicd-automation::deployment-engineer"でTaskツールを使用
- プロンプト: "ワークフロータイプ[--trunk-basedまたは--feature-branch]に基づいてブランチ戦略を準備。フィーチャーブランチの場合: ブランチ名がパターン（feature|bugfix|hotfix)/<ticket>-<description>に従うことを確認。トランクベースの場合: 必要に応じてフィーチャーフラグ戦略でメインへの直接プッシュを準備。現在のブランチ: [ブランチを挿入]、ターゲット: [ターゲットブランチを挿入]。ターゲットブランチとの競合がないことを確認。"
- 期待される出力: ブランチ準備コマンドと競合状態

### 2. プッシュ前検証
- subagent_type="cicd-automation::deployment-engineer"でTaskツールを使用
- プロンプト: "最終プッシュ前チェックを実行: 1) すべてのCIチェックが合格することを確認、2) コミットに機密データがないことを確認、3) 必要な場合はコミット署名を検証、4) ブランチ保護ルールを確認、5) すべてのレビューコメントに対処済みを確認。テスト要約: [テスト結果を挿入]。レビュー状態: [レビュー要約を挿入]。"
- 前回からのコンテキスト: すべての前回の検証結果
- 期待される出力: プッシュ準備確認またはブロッキング問題

## フェーズ5: プルリクエスト作成

### 1. PR説明生成
- subagent_type="documentation-generation::docs-architect"でTaskツールを使用
- プロンプト: "以下を含む包括的なPR説明を作成: 1) 変更の要約（何をなぜ）、2) 変更タイプチェックリスト、3) [テスト結果を挿入]からのテスト実施要約、4) UI変更がある場合はスクリーンショット/記録、5) [デプロイ考慮事項を挿入]からのデプロイノート、6) 関連する問題/チケット、7) 該当する場合は破壊的変更セクション: [破壊的変更を挿入]、8) レビュアーチェックリスト。GitHub flavored Markdownとしてフォーマット。"
- 前回からのコンテキスト: すべての検証結果、テスト結果、破壊的変更
- 期待される出力: Markdownでの完全なPR説明

### 2. PRメタデータと自動化設定
- subagent_type="cicd-automation::deployment-engineer"でTaskツールを使用
- プロンプト: "PRメタデータを設定: 1) CODEOWNERSに基づいて適切なレビュアーを割り当て、2) ラベル（タイプ、優先度、コンポーネント）を追加、3) 関連する問題をリンク、4) 該当する場合はマイルストーンを設定、5) マージ戦略（squash/merge/rebase）を設定、6) すべてのチェックが合格した場合は自動マージを設定。ドラフト状態を考慮: [--draft-prフラグ]。テスト状態を含める: [テスト要約を挿入]。"
- 前回からのコンテキスト: PR説明、テスト結果、レビュー状態
- 期待される出力: PR設定コマンドと自動化ルール

## 成功基準

- ✅ すべてのクリティカルおよび高重大度コード問題が解決済み
- ✅ テストカバレッジが維持または改善（目標: >80%）
- ✅ すべてのテストが合格（ユニット、統合、e2e）
- ✅ コミットメッセージがConventional Commits形式に従う
- ✅ ターゲットブランチとのマージ競合なし
- ✅ すべての必要セクションを含む完全なPR説明
- ✅ ブランチ保護ルールを満たす
- ✅ クリティカルな脆弱性なしでセキュリティスキャン完了
- ✅ 許容範囲内のパフォーマンスベンチマーク
- ✅ API変更のためのドキュメント更新

## ロールバック手順

マージ後の問題の場合:

1. **即座の復元**: `git revert <commit-hash>`で復元PRを作成
2. **フィーチャーフラグ無効化**: フィーチャーフラグを使用している場合、即座に無効化
3. **ホットフィックスブランチ**: クリティカルな問題の場合、mainからhotfixブランチを作成
4. **コミュニケーション**: 指定されたチャンネルを通じてチームに通知
5. **根本原因分析**: 事後検証テンプレートで問題を文書化

## ベストプラクティスリファレンス

- **コミット頻度**: 早期に頻繁にコミットするが、各コミットがアトミックであることを確保
- **ブランチ命名**: `(feature|bugfix|hotfix|docs|chore)/<ticket-id>-<brief-description>`
- **PRサイズ**: 効果的なレビューのためにPRを400行以下に保つ
- **レビュー対応**: 24時間以内にレビューコメントに対処
- **マージ戦略**: フィーチャーブランチにはSquash、リリースブランチにはMerge
- **署名**: mainブランチ変更には少なくとも2つの承認が必要
