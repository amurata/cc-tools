---
name: tdd-meaningful-test
description: 意味のあるテストかどうかを判断するスキル。3つの基準（壊れたら困る、リファクタリング可能性、モックの適切性）で評価し、プロジェクト特性に応じたカバレッジ目標を設定する。カバレッジ数値追求ではなく、テストの意味を重視。
---

# 意味のあるテスト判断スキル

テストを書く際に「このテストは意味があるか？」を判断し、適切なカバレッジ目標を設定します。

## 判断フロー

```
1. テスト対象のコードを分析
2. 3つの基準で評価
3. テストを書くべきか判断
4. カバレッジ目標を設定
```

## 3つの基準

### 基準1: 壊れたら困るか？

以下に該当する場合、**必ずテストを書く**：

| カテゴリ | 具体例 | 優先度 |
|---------|-------|-------|
| ビジネスロジック | 料金計算、ポイント付与、在庫管理 | 最高 |
| データ整合性 | 外部キー制約、トランザクション処理 | 最高 |
| セキュリティ | 認証、認可、暗号化、入力検証 | 最高 |
| 法的要件 | 監査ログ、個人情報処理、同意管理 | 最高 |

### 基準2: リファクタリング可能性

動作保証がないとコード変更が怖い場合、**テストを書く**：

| カテゴリ | 具体例 | 優先度 |
|---------|-------|-------|
| 複雑なアルゴリズム | ソート、探索、最適化ロジック | 高 |
| 並行処理 | Promise.all、キュー処理、排他制御 | 高 |
| 状態管理 | キャッシュ、セッション、状態遷移 | 高 |
| エラーハンドリング | リトライ、フォールバック、補償処理 | 高 |

### 基準3: モックの適切性

モックの量で判断：

| 状況 | 判断 |
|-----|------|
| モック0-2個 | ユニットテストで問題なし ✅ |
| モック3-5個 | 設計を見直すか、統合テストを検討 ⚠️ |
| モック6個以上 | 統合テストに切り替え、またはリファクタリング ❌ |

## テストを書かなくてよい場合

以下は**テスト不要**（または統合テストで代替）：

- ❌ 単純なgetter/setter
- ❌ 外部ライブラリの動作確認
- ❌ 設定値の読み込みだけのコード
- ❌ ログ出力だけの関数
- ❌ UIの見た目（スナップショットテストで代替可）

## カバレッジ目標設定

### プロジェクト特性に応じた目標

```
┌─────────────────────────┬────────────────┐
│ プロジェクト特性         │ 全体カバレッジ  │
├─────────────────────────┼────────────────┤
│ シンプルなCRUDアプリ     │ 25-40%        │
│ 一般的なWebアプリ        │ 40-50%        │
│ ビジネスロジック中心     │ 50-70%        │
│ 金融・医療・セキュリティ  │ 70-90%        │
└─────────────────────────┴────────────────┘
```

### レイヤー別目標

```
┌─────────────────────────┬────────────────┐
│ レイヤー                 │ カバレッジ目標  │
├─────────────────────────┼────────────────┤
│ コアビジネスロジック     │ 70%以上        │
│ ドメインモデル           │ 60%以上        │
│ ユースケース/サービス    │ 50%以上        │
│ インフラ層（DB、API）    │ 統合テストで担保│
│ UI層                    │ 20-30%（E2Eで補完）│
└─────────────────────────┴────────────────┘
```

### 目標設定の手順

```
1. プロジェクト全体の性質を判断
   → 全体目標を設定

2. 各レイヤーを特定
   → レイヤー別目標を設定

3. 「意味のある」テスト対象を洗い出し
   → 3つの基準で評価

4. テスト対象のカバレッジを優先的に確保
   → 数値は結果として達成
```

## 実践例

### 例1: 料金計算ロジック

```typescript
// このコードはテストすべきか？
function calculatePrice(items: Item[], discount: Discount): number {
  // 複雑なビジネスロジック
}
```

**判断**:
- 壊れたら困る: ✅ 収益に直結
- リファクタリング可能性: ✅ 複雑なロジック
- モックの適切性: ✅ 純粋関数、モック不要

**結論**: **必ずテストを書く** → カバレッジ90%以上目標

### 例2: ログ出力ユーティリティ

```typescript
// このコードはテストすべきか？
function logInfo(message: string): void {
  console.log(`[INFO] ${message}`);
}
```

**判断**:
- 壊れたら困る: ❌ ログが出なくても業務は止まらない
- リファクタリング可能性: ❌ 単純すぎる
- モックの適切性: ❌ テストするならconsole.logをモック必要

**結論**: **テスト不要**

### 例3: API呼び出しラッパー

```typescript
// このコードはテストすべきか？
async function fetchUser(id: string): Promise<User> {
  const response = await api.get(`/users/${id}`);
  return response.data;
}
```

**判断**:
- 壊れたら困る: ⚠️ 依存度による
- リファクタリング可能性: ❌ 単純なラッパー
- モックの適切性: ⚠️ APIモックが必要

**結論**: **統合テストで担保** または **E2Eテストで担保**

## アンチパターン

### ❌ カバレッジのためのテスト
```typescript
// 悪い例: 意味のないテスト
test('constructor sets name', () => {
  const user = new User('Alice');
  expect(user.name).toBe('Alice');
});
```

### ❌ モックだらけのテスト
```typescript
// 悪い例: 何をテストしているか不明
test('service works', () => {
  const mockA = jest.fn();
  const mockB = jest.fn();
  const mockC = jest.fn();
  const mockD = jest.fn();
  // ... 実際の動作を検証していない
});
```

### ✅ 意味のあるテスト
```typescript
// 良い例: ビジネスロジックの検証
test('discount is applied correctly for premium users', () => {
  const cart = createCart([item1, item2]);
  const user = createPremiumUser();
  
  const total = calculateTotal(cart, user);
  
  expect(total).toBe(expectedDiscountedPrice);
});
```

## 適用方法

このスキルは以下の場面で自動的に適用されます：
- テストコードを書く前
- カバレッジ目標を設定する時
- テスト戦略をレビューする時
- 「このテストは必要か？」と問われた時
