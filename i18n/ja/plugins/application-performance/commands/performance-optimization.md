# パフォーマンス最適化

> **[English](../../../plugins/application-performance/commands/performance-optimization.md)** | **日本語**

専門的なパフォーマンスと最適化エージェントを使用してアプリケーションパフォーマンスをエンドツーエンドで最適化します：

[拡張思考: このワークフローは、アプリケーションスタック全体にわたる包括的なパフォーマンス最適化プロセスを調整します。深いプロファイリングとベースライン確立から始まり、ワークフローは各システムレイヤーでのターゲット最適化、負荷テストを通じた改善検証、持続的パフォーマンスのための継続的モニタリング確立へと進みます。各フェーズは前のフェーズからのインサイトに基づいて構築され、理論的改善ではなく実際のボトルネックに対処するデータ駆動の最適化戦略を作成します。ワークフローは、最新のオブザーバビリティプラクティス、ユーザー中心のパフォーマンスメトリクス、コスト効率的な最適化戦略を強調します。]

## フェーズ1: パフォーマンスプロファイリングとベースライン

### 1. 包括的パフォーマンスプロファイリング
- subagent_type="performance-engineer"でTaskツールを使用
- プロンプト: "$ARGUMENTSのアプリケーションパフォーマンスを包括的にプロファイルしてください。CPU使用量のフレームグラフ、メモリ分析のヒープダンプ、I/O操作のトレース、ホットパスの識別を生成してください。利用可能な場合はDataDogやNew RelicなどのAPMツールを使用してください。データベースクエリプロファイリング、APIレスポンスタイム、フロントエンドレンダリングメトリクスを含めてください。すべてのクリティカルなユーザージャーニーのパフォーマンスベースラインを確立してください。"
- コンテキスト: 初期パフォーマンス調査
- 出力: フレームグラフ、メモリ分析、ボトルネック識別、ベースラインメトリクスを含む詳細なパフォーマンスプロファイル

### 2. オブザーバビリティスタック評価
- subagent_type="observability-engineer"でTaskツールを使用
- プロンプト: "$ARGUMENTSの現在のオブザーバビリティセットアップを評価してください。既存のモニタリング、OpenTelemetryによる分散トレーシング、ログ集約、メトリクス収集をレビューしてください。可視性のギャップ、欠落しているメトリクス、より良い計装が必要な領域を識別してください。APMツール統合とビジネスクリティカルな操作のカスタムメトリクスを推奨してください。"
- コンテキスト: ステップ1からのパフォーマンスプロファイル
- 出力: オブザーバビリティ評価レポート、計装ギャップ、モニタリング推奨事項

### 3. ユーザー体験分析
- subagent_type="performance-engineer"でTaskツールを使用
- プロンプト: "$ARGUMENTSのユーザー体験メトリクスを分析してください。Core Web Vitals（LCP、FID、CLS）、ページロードタイム、インタラクティブまでの時間、知覚パフォーマンスを測定してください。利用可能な場合はリアルユーザーモニタリング（RUM）データを使用してください。パフォーマンスが悪いユーザージャーニーとそのビジネスインパクトを識別してください。"
- コンテキスト: ステップ1からのパフォーマンスベースライン
- 出力: UXパフォーマンスレポート、Core Web Vitals分析、ユーザーインパクト評価

## フェーズ2: データベースとバックエンド最適化

### 4. データベースパフォーマンス最適化
- subagent_type="database-cloud-optimization::database-optimizer"でTaskツールを使用
- プロンプト: "プロファイリングデータ: {context_from_phase_1}に基づいて$ARGUMENTSのデータベースパフォーマンスを最適化してください。スロークエリログを分析し、欠落しているインデックスを作成し、実行計画を最適化し、Redis/Memcachedでクエリ結果キャッシングを実装してください。コネクションプーリング、プリペアドステートメント、バッチ処理の機会をレビューしてください。必要に応じてリードレプリカとデータベースシャーディングを検討してください。"
- コンテキスト: フェーズ1からのパフォーマンスボトルネック
- 出力: 最適化されたクエリ、新しいインデックス、キャッシング戦略、コネクションプール設定

### 5. バックエンドコードとAPI最適化
- subagent_type="backend-development::backend-architect"でTaskツールを使用
- プロンプト: "ボトルネック: {context_from_phase_1}をターゲットとして$ARGUMENTSのバックエンドサービスを最適化してください。効率的なアルゴリズムを実装し、アプリケーションレベルキャッシングを追加し、N+1クエリを最適化し、async/awaitパターンを効果的に使用してください。ページネーション、レスポンス圧縮、GraphQLクエリ最適化、バッチAPI操作を実装してください。耐障害性のためにサーキットブレーカーとバルクヘッドを追加してください。"
- コンテキスト: ステップ4からのデータベース最適化、フェーズ1からのプロファイリングデータ
- 出力: 最適化されたバックエンドコード、キャッシング実装、API改善、耐障害性パターン

### 6. マイクロサービスと分散システム最適化
- subagent_type="performance-engineer"でTaskツールを使用
- プロンプト: "$ARGUMENTSの分散システムパフォーマンスを最適化してください。サービス間通信を分析し、サービスメッシュ最適化を実装し、メッセージキューパフォーマンス（Kafka/RabbitMQ）を最適化し、ネットワークホップを削減してください。分散キャッシング戦略を実装し、シリアライゼーション/デシリアライゼーションを最適化してください。"
- コンテキスト: ステップ5からのバックエンド最適化
- 出力: サービス通信改善、メッセージキュー最適化、分散キャッシングセットアップ

## フェーズ3: フロントエンドとCDN最適化

### 7. フロントエンドバンドルとロード最適化
- subagent_type="frontend-developer"でTaskツールを使用
- プロンプト: "Core Web Vitals: {context_from_phase_1}をターゲットとして$ARGUMENTSのフロントエンドパフォーマンスを最適化してください。コード分割、ツリーシェイキング、遅延読み込み、動的インポートを実装してください。webpack/rollup分析でバンドルサイズを最適化してください。リソースヒント（prefetch、preconnect、preload）を実装してください。クリティカルレンダリングパスを最適化し、レンダリングブロックリソースを削除してください。"
- コンテキスト: フェーズ1からのUX分析、フェーズ2からのバックエンド最適化
- 出力: 最適化されたバンドル、遅延読み込み実装、改善されたCore Web Vitals

### 8. CDNとエッジ最適化
- subagent_type="cloud-infrastructure::cloud-architect"でTaskツールを使用
- プロンプト: "$ARGUMENTSのCDNとエッジパフォーマンスを最適化してください。最適なキャッシングのためにCloudFlare/CloudFrontを設定し、動的コンテンツのためにエッジ関数を実装し、レスポンシブ画像とWebP/AVIF形式で画像最適化をセットアップしてください。HTTP/2とHTTP/3を設定し、Brotli圧縮を実装してください。グローバルユーザーのために地理的分散をセットアップしてください。"
- コンテキスト: ステップ7からのフロントエンド最適化
- 出力: CDN設定、エッジキャッシングルール、圧縮セットアップ、地理的最適化

### 9. モバイルとProgressive Web App最適化
- subagent_type="frontend-mobile-development::mobile-developer"でTaskツールを使用
- プロンプト: "$ARGUMENTSのモバイル体験を最適化してください。オフライン機能のためにサービスワーカーを実装し、適応的ロードで遅いネットワークのために最適化してください。モバイルCPU向けにJavaScript実行時間を削減してください。長いリスト用に仮想スクロールを実装してください。タッチレスポンシブネスとスムーズなアニメーションを最適化してください。該当する場合はReact Native/Flutter固有の最適化を検討してください。"
- コンテキスト: ステップ7-8からのフロントエンド最適化
- 出力: モバイル最適化コード、PWA実装、オフライン機能

## フェーズ4: 負荷テストと検証

### 10. 包括的負荷テスト
- subagent_type="performance-engineer"でTaskツールを使用
- プロンプト: "k6/Gatling/Artilleryを使用して$ARGUMENTSの包括的負荷テストを実施してください。本番トラフィックパターンに基づいた現実的な負荷シナリオを設計してください。通常負荷、ピーク負荷、ストレスシナリオをテストしてください。該当する場合はAPIテスト、ブラウザベーステスト、WebSocketテストを含めてください。様々な負荷レベルでのレスポンスタイム、スループット、エラー率、リソース使用率を測定してください。"
- コンテキスト: フェーズ1-3からのすべての最適化
- 出力: 負荷テスト結果、負荷下のパフォーマンス、限界点、スケーラビリティ分析

### 11. パフォーマンスリグレッションテスト
- subagent_type="performance-testing-review::test-automator"でTaskツールを使用
- プロンプト: "$ARGUMENTSの自動パフォーマンスリグレッションテストを作成してください。主要メトリクスのパフォーマンスバジェットをセットアップし、GitHub Actionsなどを使用してCI/CDパイプラインと統合してください。フロントエンド用のLighthouse CIテスト、Artilleryを使用したAPIパフォーマンステスト、データベースパフォーマンスベンチマークを作成してください。パフォーマンスリグレッション用の自動ロールバックトリガーを実装してください。"
- コンテキスト: ステップ10からの負荷テスト結果、フェーズ1からのベースラインメトリクス
- 出力: パフォーマンステストスイート、CI/CD統合、リグレッション防止システム

## フェーズ5: モニタリングと継続的最適化

### 12. 本番モニタリングセットアップ
- subagent_type="observability-engineer"でTaskツールを使用
- プロンプト: "$ARGUMENTSの本番パフォーマンスモニタリングを実装してください。DataDog/New Relic/DynatraceでAPMをセットアップし、OpenTelemetryで分散トレーシングを設定し、カスタムビジネスメトリクスを実装してください。主要メトリクス用のGrafanaダッシュボードを作成し、パフォーマンス低下のためにPagerDutyアラートをセットアップしてください。エラーバジェット付きのクリティカルサービスのSLI/SLOを定義してください。"
- コンテキスト: すべての前フェーズからのパフォーマンス改善
- 出力: モニタリングダッシュボード、アラートルール、SLI/SLO定義、ランブック

### 13. 継続的パフォーマンス最適化
- subagent_type="performance-engineer"でTaskツールを使用
- プロンプト: "$ARGUMENTSの継続的最適化プロセスを確立してください。パフォーマンスバジェット追跡を作成し、パフォーマンス変更のA/Bテストを実装し、本番環境での継続的プロファイリングをセットアップしてください。最適化機会のバックログを文書化し、キャパシティプランニングモデルを作成し、定期的なパフォーマンスレビューサイクルを確立してください。"
- コンテキスト: ステップ12からのモニタリングセットアップ、すべての以前の最適化作業
- 出力: パフォーマンスバジェット追跡、最適化バックログ、キャパシティプランニング、レビュープロセス

## 設定オプション

- **performance_focus**: "latency" | "throughput" | "cost" | "balanced" (デフォルト: "balanced")
- **optimization_depth**: "quick-wins" | "comprehensive" | "enterprise" (デフォルト: "comprehensive")
- **tools_available**: ["datadog", "newrelic", "prometheus", "grafana", "k6", "gatling"]
- **budget_constraints**: インフラストラクチャ変更の最大許容コストを設定
- **user_impact_tolerance**: "zero-downtime" | "maintenance-window" | "gradual-rollout"

## 成功基準

- **レスポンスタイム**: クリティカルエンドポイントでP50 < 200ms、P95 < 1s、P99 < 2s
- **Core Web Vitals**: LCP < 2.5s、FID < 100ms、CLS < 0.1
- **スループット**: <1%エラー率で現在のピーク負荷の2倍をサポート
- **データベースパフォーマンス**: クエリP95 < 100ms、クエリ > 1sなし
- **リソース使用率**: 通常負荷下でCPU < 70%、メモリ < 80%
- **コスト効率**: ドルあたりのパフォーマンスが最低30%改善
- **モニタリングカバレッジ**: アラート付きで100%のクリティカルパスが計装されている

パフォーマンス最適化ターゲット: $ARGUMENTS
