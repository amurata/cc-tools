> **[English](../../../../../plugins/llm-application-dev/skills/prompt-engineering-patterns/SKILL.md)** | **日本語**

---
name: prompt-engineering-patterns
description: LLMのパフォーマンス、信頼性、制御性を本番環境で最大化するための高度なプロンプトエンジニアリング技術をマスターします。プロンプトの最適化、LLM出力の改善、または本番環境プロンプトテンプレートの設計時に使用します。
---

# プロンプトエンジニアリングパターン

LLMのパフォーマンス、信頼性、制御性を最大化するための高度なプロンプトエンジニアリング技術をマスターします。

## このスキルを使用する場合

- 本番環境LLMアプリケーションのための複雑なプロンプトの設計
- プロンプトパフォーマンスと一貫性の最適化
- 構造化推論パターンの実装（chain-of-thought、tree-of-thought）
- 動的な例選択によるfew-shot学習システムの構築
- 変数補間による再利用可能なプロンプトテンプレートの作成
- 一貫性のない出力を生成するプロンプトのデバッグと改良
- 専門AIアシスタントのためのシステムプロンプトの実装

## コア機能

### 1. Few-Shot学習
- 例選択戦略（セマンティック類似性、多様性サンプリング）
- コンテキストウィンドウ制約と例数のバランス
- 入力-出力ペアによる効果的なデモンストレーションの構築
- ナレッジベースからの動的な例検索
- 戦略的な例選択によるエッジケースの処理

### 2. Chain-of-Thoughtプロンプト
- ステップバイステップ推論の引き出し
- 「Let's think step by step」によるゼロショットCoT
- 推論トレース付きfew-shot CoT
- Self-consistency技術（複数の推論パスをサンプリング）
- 検証と妥当性確認ステップ

### 3. プロンプト最適化
- 反復的な改良ワークフロー
- プロンプトバリエーションのA/Bテスト
- プロンプトパフォーマンスメトリクスの測定（精度、一貫性、レイテンシ）
- 品質を維持しながらトークン使用量を削減
- エッジケースと失敗モードの処理

### 4. テンプレートシステム
- 変数補間とフォーマット
- 条件付きプロンプトセクション
- マルチターン会話テンプレート
- ロールベースのプロンプト構成
- モジュラープロンプトコンポーネント

### 5. システムプロンプト設計
- モデルの動作と制約の設定
- 出力形式と構造の定義
- ロールと専門知識の確立
- 安全性ガイドラインとコンテンツポリシー
- コンテキスト設定と背景情報

## クイックスタート

```python
from prompt_optimizer import PromptTemplate, FewShotSelector

# 構造化プロンプトテンプレートを定義
template = PromptTemplate(
    system="You are an expert SQL developer. Generate efficient, secure SQL queries.",
    instruction="Convert the following natural language query to SQL:\n{query}",
    few_shot_examples=True,
    output_format="SQL code block with explanatory comments"
)

# few-shot学習を設定
selector = FewShotSelector(
    examples_db="sql_examples.jsonl",
    selection_strategy="semantic_similarity",
    max_examples=3
)

# 最適化されたプロンプトを生成
prompt = template.render(
    query="Find all users who registered in the last 30 days",
    examples=selector.select(query="user registration date filter")
)
```

## キーパターン

### 段階的開示
必要なときだけ複雑さを追加して、シンプルなプロンプトから始める:

1. **レベル1**: 直接的な指示
   - "この記事を要約"

2. **レベル2**: 制約を追加
   - "この記事を3つの箇条書きで要約し、主要な発見に焦点を当てる"

3. **レベル3**: 推論を追加
   - "この記事を読み、主要な発見を特定し、次に3つの箇条書きで要約"

4. **レベル4**: 例を追加
   - 入力-出力ペアで2-3の要約例を含める

### 指示階層
```
[システムコンテキスト] → [タスク指示] → [例] → [入力データ] → [出力形式]
```

### エラーリカバリ
失敗を適切に処理するプロンプトを構築:
- フォールバック指示を含める
- 信頼度スコアを要求
- 不確実な場合に代替解釈を求める
- 欠落情報の示し方を指定

## ベストプラクティス

1. **具体的であること**: 曖昧なプロンプトは一貫性のない結果を生成
2. **見せる、言わない**: 例は説明よりも効果的
3. **広範囲にテスト**: 多様で代表的な入力で評価
4. **迅速に反復**: 小さな変更が大きな影響を与える可能性
5. **パフォーマンスを監視**: 本番環境でメトリクスを追跡
6. **バージョン管理**: プロンプトを適切なバージョニングでコードとして扱う
7. **意図を文書化**: プロンプトがその構造である理由を説明

## よくある落とし穴

- **過度な設計**: シンプルなものを試す前に複雑なプロンプトから始める
- **例の汚染**: ターゲットタスクと一致しない例を使用
- **コンテキストオーバーフロー**: 過度の例でトークン制限を超える
- **曖昧な指示**: 複数の解釈の余地を残す
- **エッジケースの無視**: 異常または境界入力でテストしない

## 統合パターン

### RAGシステムと
```python
# 検索されたコンテキストとプロンプトエンジニアリングを組み合わせる
prompt = f"""以下のコンテキストを考慮:
{retrieved_context}

{few_shot_examples}

質問: {user_question}

上記のコンテキストのみに基づいて詳細な回答を提供。コンテキストに十分な情報が含まれていない場合、何が欠けているかを明示的に述べる。"""
```

### 検証と
```python
# 自己検証ステップを追加
prompt = f"""{main_task_prompt}

応答を生成した後、これらの基準を満たすことを検証:
1. 質問に直接回答
2. 提供されたコンテキストからの情報のみを使用
3. 特定のソースを引用
4. 不確実性を認める

検証が失敗した場合、応答を修正。"""
```

## パフォーマンス最適化

### トークン効率
- 冗長な単語やフレーズを削除
- 最初の定義後に略語を一貫して使用
- 類似した指示を統合
- 安定したコンテンツをシステムプロンプトに移動

### レイテンシ削減
- 品質を犠牲にせずにプロンプトの長さを最小化
- 長い形式の出力にストリーミングを使用
- 共通プロンプトプレフィックスをキャッシュ
- 可能な場合は類似リクエストをバッチ化

## リソース

- **references/few-shot-learning.md**: 例選択と構築の詳細
- **references/chain-of-thought.md**: 高度な推論引き出し技術
- **references/prompt-optimization.md**: 体系的な改良ワークフロー
- **references/prompt-templates.md**: 再利用可能なテンプレートパターン
- **references/system-prompts.md**: システムレベルのプロンプト設計
- **assets/prompt-template-library.md**: 実証済みのプロンプトテンプレート
- **assets/few-shot-examples.json**: キュレーションされた例データセット
- **scripts/optimize-prompt.py**: 自動プロンプト最適化ツール

## 成功メトリクス

プロンプトに対してこれらのKPIを追跡:
- **精度**: 出力の正しさ
- **一貫性**: 類似入力間での再現性
- **レイテンシ**: 応答時間（P50、P95、P99）
- **トークン使用量**: リクエストあたりの平均トークン
- **成功率**: 有効な出力の割合
- **ユーザー満足度**: 評価とフィードバック

## 次のステップ

1. 一般的なパターンのためのプロンプトテンプレートライブラリをレビュー
2. 特定のユースケースでfew-shot学習を実験
3. プロンプトバージョニングとA/Bテストを実装
4. 自動評価パイプラインを設定
5. プロンプトエンジニアリングの決定と学習を文書化
