> **[English](../../../../../plugins/database-design/skills/postgresql/SKILL.md)** | **日本語**

---
name: postgresql-table-design
description: PostgreSQL固有のスキーマを設計します。ベストプラクティス、データ型、インデックス、制約、パフォーマンスパターン、および高度な機能をカバーします。
---

# PostgreSQL テーブル設計

## コアルール

- 参照テーブル（ユーザー、注文など）には **PRIMARY KEY** を定義します。時系列/イベント/ログデータには必ずしも必要ありません。使用する場合は `BIGINT GENERATED ALWAYS AS IDENTITY` を推奨します。グローバルな一意性/不透明性が必要な場合のみ `UUID` を使用してください。
- **最初に正規化（第3正規形まで）** してデータの冗長性と更新時の異常を排除します。結合パフォーマンスが問題になることが証明された、測定された高ROIの読み取りに対して**のみ**非正規化を行います。時期尚早な非正規化はメンテナンスの負担を生みます。
- 意味的に必要な場所すべてに **NOT NULL** を追加します。一般的な値には **DEFAULT** を使用します。
- **実際にクエリするアクセスパスのインデックスを作成** します: PK/unique（自動）、**FK列（手動！）**、頻繁なフィルタ/ソート、および結合キー。
- イベント時間には **TIMESTAMPTZ**、金額には **NUMERIC**、文字列には **TEXT**、整数値には **BIGINT**、浮動小数点数には **DOUBLE PRECISION**（または正確な小数の算術演算には `NUMERIC`）を推奨します。

## PostgreSQL の「落とし穴」

- **識別子**: 引用符なし → 小文字に変換されます。引用符付き/大文字小文字混在の名前は避けてください。慣例: テーブル/列名には `snake_case` を使用します。
- **Unique + NULLs**: UNIQUE は複数の NULL を許可します。1つの NULL に制限するには `UNIQUE (...) NULLS NOT DISTINCT` (PG15+) を使用します。
- **FK インデックス**: PostgreSQL は FK 列に自動的にインデックスを作成**しません**。追加してください。
- **暗黙の強制変換なし**: 長さ/精度のオーバーフローはエラーになります（切り捨てなし）。例: `NUMERIC(2,0)` に 999 を挿入すると、静かに切り捨てたり丸めたりする一部のデータベースとは異なり、エラーで失敗します。
- **シーケンス/ID のギャップ**（正常です。「修正」しないでください）。ロールバック、クラッシュ、および同時トランザクションにより、ID シーケンスにギャップ（1, 2, 5, 6...）が生じます。これは期待される動作です。ID を連続させようとしないでください。
- **ヒープストレージ**: デフォルトではクラスタ化 PK はありません（SQL Server/MySQL InnoDB とは異なります）。`CLUSTER` は一度限りの再編成であり、その後の挿入では維持されません。ディスク上の行順序は、明示的にクラスタ化されない限り挿入順です。
- **MVCC**: 更新/削除はデッドタプルを残します。vacuum がそれらを処理します。ホットなワイド行のチャーン（激しい更新）を避けるように設計してください。

## データ型

- **ID**: `BIGINT GENERATED ALWAYS AS IDENTITY` を推奨（`GENERATED BY DEFAULT` も可）。マージ/フェデレーション/分散システムで使用される場合、または不透明な ID の場合は `UUID`。`uuidv7()`（PG18+ を使用している場合は推奨）または `gen_random_uuid()`（古い PG バージョンを使用している場合）で生成します。
- **整数**: ストレージ容量が重要でない限り `BIGINT` を推奨。より小さな範囲には `INTEGER`。制約がない限り `SMALLINT` は避けてください。
- **浮動小数点数**: ストレージ容量が重要でない限り `REAL` よりも `DOUBLE PRECISION` を推奨。正確な小数の算術演算には `NUMERIC` を使用します。
- **文字列**: `TEXT` を推奨。長さ制限が必要な場合は `VARCHAR(n)` の代わりに `CHECK (LENGTH(col) <= n)` を使用します。`CHAR(n)` は避けてください。バイナリデータには `BYTEA` を使用します。大きな文字列/バイナリ（デフォルトの閾値 2KB 超）は自動的に圧縮されて TOAST に保存されます。TOAST ストレージ: `PLAIN`（TOAST なし）、`EXTENDED`（圧縮 + アウトオブライン）、`EXTERNAL`（アウトオブライン、圧縮なし）、`MAIN`（圧縮、可能ならインライン維持）。デフォルトの `EXTENDED` が通常は最適です。`ALTER TABLE tbl ALTER COLUMN col SET STORAGE strategy` で制御し、閾値は `ALTER TABLE tbl SET (toast_tuple_target = 4096)` で設定します。大文字小文字を区別しない場合: ロケール/アクセント処理には非決定論的照合順序を使用。プレーン ASCII には `LOWER(col)` の式インデックス（大文字小文字を区別しない PK/FK/UNIQUE が必要な場合を除き推奨）または `CITEXT` を使用します。
- **金額**: `NUMERIC(p,s)`（浮動小数点数は絶対に使用しない）。
- **時間**: タイムスタンプには `TIMESTAMPTZ`。日付のみには `DATE`。期間には `INTERVAL`。`TIMESTAMP`（タイムゾーンなし）は避けてください。トランザクション開始時間には `now()`、現在の実時間には `clock_timestamp()` を使用します。
- **ブール値**: 3値ロジックが必要でない限り、`NOT NULL` 制約付きの `BOOLEAN`。
- **列挙型**: 小さな安定したセット（例: 米国の州、曜日）には `CREATE TYPE ... AS ENUM`。ビジネスロジック主導で進化する値（例: 注文ステータス）の場合 → TEXT（または INT）+ CHECK またはルックアップテーブルを使用します。
- **配列**: `TEXT[]`、`INTEGER[]` など。要素をクエリする順序付きリストに使用します。包含（`@>`, `<@`）および重複（`&&`）クエリのために **GIN** でインデックスを作成します。アクセス: `arr[1]`（1始まり）、`arr[1:3]`（スライス）。タグ、カテゴリに適しています。リレーションには避けてください（代わりにジャンクションテーブルを使用）。リテラル構文: `'{val1,val2}'` または `ARRAY[val1,val2]`。
- **範囲型**: 期間用の `daterange`、`numrange`、`tstzrange`。重複（`&&`）、包含（`@>`）、演算子をサポートします。**GiST** でインデックスを作成します。スケジューリング、バージョニング、数値範囲に適しています。境界スキームを選択し、一貫して使用してください。デフォルトでは `[)`（包含/排他）を推奨します。
- **ネットワーク型**: IP アドレス用の `INET`、ネットワーク範囲用の `CIDR`、MAC アドレス用の `MACADDR`。ネットワーク演算子（`<<`, `>>`, `&&`）をサポートします。
- **幾何学型**: 2D 空間データ用の `POINT`, `LINE`, `POLYGON`, `CIRCLE`。**GiST** でインデックスを作成します。高度な空間機能には **PostGIS** を検討してください。
- **テキスト検索**: 全文検索ドキュメント用の `TSVECTOR`、検索クエリ用の `TSQUERY`。`tsvector` には **GIN** でインデックスを作成します。常に言語を指定してください: `to_tsvector('english', col)` および `to_tsquery('english', 'query')`。単一引数のバージョンは使用しないでください。これはインデックス式とクエリの両方に適用されます。
- **ドメイン型**: 検証付きの再利用可能なカスタム型には `CREATE DOMAIN email AS TEXT CHECK (VALUE ~ '^[^@]+@[^@]+$')`。テーブル間で制約を強制します。
- **複合型**: 列内の構造化データには `CREATE TYPE address AS (street TEXT, city TEXT, zip TEXT)`。`(col).field` 構文でアクセスします。
- **JSONB**: JSON よりも推奨。**GIN** でインデックスを作成します。オプション/半構造化属性にのみ使用してください。内容の元の順序を維持しなければならない場合のみ JSON を使用してください。
- **ベクトル型**: エンベディングのベクトル類似性検索用の `pgvector` による `vector` 型。

### 以下のデータ型は使用しないでください
- `timestamp`（タイムゾーンなし）は使用しないでください。代わりに `timestamptz` を使用してください。
- `char(n)` または `varchar(n)` は使用しないでください。代わりに `text` を使用してください。
- `money` 型は使用しないでください。代わりに `numeric` を使用してください。
- `timetz` 型は使用しないでください。代わりに `timestamptz` を使用してください。
- `timestamptz(0)` やその他の精度指定は使用しないでください。代わりに `timestamptz` を使用してください。
- `serial` 型は使用しないでください。代わりに `generated always as identity` を使用してください。

## テーブルタイプ

- **通常**: デフォルト。完全に耐久性があり、ログに記録されます。
- **TEMPORARY**: セッションスコープ、自動削除、ログなし。スクラッチ作業に高速です。
- **UNLOGGED**: 永続的ですがクラッシュセーフではありません。書き込みが高速。キャッシュ/ステージングに適しています。

## 行レベルセキュリティ (RLS)

`ALTER TABLE tbl ENABLE ROW LEVEL SECURITY` で有効にします。ポリシーを作成します: `CREATE POLICY user_access ON orders FOR SELECT TO app_users USING (user_id = current_user_id())`。行レベルでの組み込みのユーザーベースのアクセス制御。

## 制約

- **PK**: 暗黙の UNIQUE + NOT NULL。B-tree インデックスを作成します。
- **FK**: `ON DELETE/UPDATE` アクション（`CASCADE`, `RESTRICT`, `SET NULL`, `SET DEFAULT`）を指定します。参照列に明示的なインデックスを追加します。結合を高速化し、親の削除/更新時のロックの問題を防ぎます。トランザクション終了時にチェックされる循環 FK 依存関係には `DEFERRABLE INITIALLY DEFERRED` を使用します。
- **UNIQUE**: B-tree インデックスを作成します。`NULLS NOT DISTINCT` (PG15+) でない限り、複数の NULL を許可します。標準動作: `(1, NULL)` と `(1, NULL)` は許可されます。`NULLS NOT DISTINCT` の場合: `(1, NULL)` は1つだけ許可されます。重複する NULL が特に必要でない限り、`NULLS NOT DISTINCT` を推奨します。
- **CHECK**: 行ローカルの制約。NULL 値はチェックを通過します（3値ロジック）。例: `CHECK (price > 0)` は NULL 価格を許可します。強制するには `NOT NULL` と組み合わせます: `price NUMERIC NOT NULL CHECK (price > 0)`。
- **EXCLUDE**: 演算子を使用して重複する値を防ぎます。`EXCLUDE USING gist (room_id WITH =, booking_period WITH &&)` は部屋の二重予約を防ぎます。適切なインデックスタイプ（多くの場合 GiST）が必要です。

## インデックス

- **B-tree**: 等価/範囲クエリ（`=`, `<`, `>`, `BETWEEN`, `ORDER BY`）のデフォルト。
- **複合**: 順序が重要です。最左プレフィックスでの等価性の場合にインデックスが使用されます（`WHERE a = ? AND b > ?` は `(a,b)` のインデックスを使用しますが、`WHERE b = ?` は使用しません）。最も選択的/頻繁にフィルタリングされる列を最初に配置します。
- **カバリング**: `CREATE INDEX ON tbl (id) INCLUDE (name, email)` - テーブルにアクセスせずにインデックスのみのスキャンを行うために、キー以外の列を含めます。
- **部分**: ホットなサブセット用（`WHERE status = 'active'` → `CREATE INDEX ON tbl (user_id) WHERE status = 'active'`）。`status = 'active'` を含むクエリはこのインデックスを使用できます。
- **式**: 計算された検索キー用（`CREATE INDEX ON tbl (LOWER(email))`）。式は WHERE 句と正確に一致する必要があります: `WHERE LOWER(email) = 'user@example.com'`。
- **GIN**: JSONB 包含/存在、配列（`@>`, `?`）、全文検索（`@@`）。
- **GiST**: 範囲、幾何学、排他制約。
- **BRIN**: 非常に大きな、自然に順序付けられたデータ（時系列）用。ストレージオーバーヘッドが最小限。ディスク上の行順序がインデックス列と相関している場合に効果的（挿入順または `CLUSTER` 後）。

## パーティショニング

- クエリが一貫してパーティションキー（多くの場合、時間/日付）でフィルタリングする非常に大きなテーブル（1億行以上）に使用します。
- 代替用途: データのプルーニングや定期的な一括置換などのデータメンテナンス作業が必要なテーブルに使用します。
- **RANGE**: 時系列に一般的（`PARTITION BY RANGE (created_at)`）。パーティションを作成: `CREATE TABLE logs_2024_01 PARTITION OF logs FOR VALUES FROM ('2024-01-01') TO ('2024-02-01')`。**TimescaleDB** は、保持ポリシーと圧縮を備えた時間ベースまたは ID ベースのパーティショニングを自動化します。
- **LIST**: 離散値用（`PARTITION BY LIST (region)`）。例: `FOR VALUES IN ('us-east', 'us-west')`。
- **HASH**: 自然キーがない場合の均等分布用（`PARTITION BY HASH (user_id)`）。モジュラスで N 個のパーティションを作成します。
- **制約除外**: クエリプランナーがプルーニングするために、パーティションに `CHECK` 制約が必要です。宣言的パーティショニング（PG10+）では自動作成されます。
- 宣言的パーティショニングまたはハイパーテーブルを推奨します。テーブル継承は使用しないでください。
- **制限**: グローバルな UNIQUE 制約はありません。PK/UNIQUE にパーティションキーを含める必要があります。パーティションテーブルからの FK はサポートされていません。トリガーを使用してください。

## 特別な考慮事項

### 更新が多いテーブル

- **ホット/コールド列の分離**: 頻繁に更新される列を別のテーブルに配置して、肥大化を最小限に抑えます。
- **`fillfactor=90` を使用**: インデックスメンテナンスを回避する HOT 更新のためのスペースを残します。
- **インデックス列の更新を避ける**: 有益な HOT 更新を防ぎます。
- **更新パターンによるパーティション化**: 頻繁に更新される行を安定したデータとは別のパーティションに分離します。

### 挿入が多いワークロード

- **インデックスを最小限にする**: クエリするものだけを作成します。すべてのインデックスは挿入を遅くします。
- **単一行挿入の代わりに `COPY` または複数行 `INSERT` を使用**します。
- **再構築可能なステージングデータには `UNLOGGED` テーブル**を使用します。書き込みがはるかに高速です。
- **一括ロードのためにインデックス作成を延期**します → インデックス削除、データロード、インデックス再作成。
- **時間/ハッシュでパーティション化**して負荷を分散します。**TimescaleDB** は、挿入が多いデータのパーティショニングと圧縮を自動化します。
- **主キーには自然キーを使用**します（例: (timestamp, device_id)）。グローバルな一意性の強制が重要な場合。多くの挿入が多いテーブルには主キーがまったく必要ありません。
- サロゲートキーが必要な場合は、**`UUID` よりも `BIGINT GENERATED ALWAYS AS IDENTITY` を推奨**します。

### Upsert フレンドリーな設計

- 競合ターゲット列に **UNIQUE インデックスが必要**です。`ON CONFLICT (col1, col2)` には、完全に一致するユニークインデックスが必要です（部分インデックスは機能しません）。
- **`EXCLUDED.column` を使用**して、挿入されるはずだった値を参照します。書き込みオーバーヘッドを減らすために、実際に変更された列のみを更新します。
- 実際の更新が必要ない場合、`DO UPDATE` よりも **`DO NOTHING` の方が高速**です。

### 安全なスキーマ進化

- **トランザクション DDL**: ほとんどの DDL 操作はトランザクション内で実行でき、ロールバックできます。安全なテストのために `BEGIN; ALTER TABLE...; ROLLBACK;` を使用します。
- **同時インデックス作成**: `CREATE INDEX CONCURRENTLY` は書き込みのブロックを回避しますが、トランザクション内では実行できません。
- **揮発性デフォルトは書き換えを引き起こす**: 揮発性デフォルト（例: `now()`, `gen_random_uuid()`）を持つ `NOT NULL` 列を追加すると、テーブル全体が書き換えられます。不揮発性デフォルトは高速です。
- **列の前に制約を削除**: 依存関係の問題を避けるために、`ALTER TABLE DROP CONSTRAINT` してから `DROP COLUMN` します。
- **関数シグネチャの変更**: 異なる引数を持つ `CREATE OR REPLACE` は、置換ではなくオーバーロードを作成します。オーバーロードが不要な場合は、古いバージョンを DROP してください。

## 生成列

- `... GENERATED ALWAYS AS (<expr>) STORED` 計算されたインデックス可能なフィールド用。PG18+ では `VIRTUAL` 列（保存されず、読み取り時に計算）が追加されます。

## 拡張機能

- **`pgcrypto`**: パスワードハッシュ用の `crypt()`。
- **`uuid-ossp`**: 代替 UUID 関数。新しいプロジェクトには `pgcrypto` を推奨します。
- **`pg_trgm`**: `%` 演算子、`similarity()` 関数によるファジーテキスト検索。`LIKE '%pattern%'` の高速化のために GIN でインデックスを作成します。
- **`citext`**: 大文字小文字を区別しないテキスト型。大文字小文字を区別しない制約が必要ない限り、`LOWER(col)` の式インデックスを推奨します。
- **`btree_gin`/`btree_gist`**: 混合型インデックス（例: JSONB とテキスト列の両方に対する GIN インデックス）を有効にします。
- **`hstore`**: キーバリューペア。主に JSONB に取って代わられましたが、単純な文字列マッピングには便利です。
- **`timescaledb`**: 時系列に不可欠。自動パーティショニング、保持、圧縮、連続集計。
- **`postgis`**: 基本的な幾何学型を超えた包括的な地理空間サポート。位置情報ベースのアプリケーションに不可欠です。
- **`pgvector`**: エンベディングのベクトル類似性検索。
- **`pgaudit`**: すべてのデータベースアクティビティの監査ログ。

## JSONB ガイダンス

- **GIN** インデックス付きの `JSONB` を推奨します。
- デフォルト: `CREATE INDEX ON tbl USING GIN (jsonb_col);` → 以下を高速化:
  - **包含** `jsonb_col @> '{"k":"v"}'`
  - **キーの存在** `jsonb_col ? 'k'`, **いずれか/すべてのキー** `?|`, `?&`
  - ネストされたドキュメントの **パス包含**
  - **論理和** `jsonb_col @> ANY(ARRAY['{"status":"active"}', '{"status":"pending"}'])`
- 重い `@>` ワークロード: より小さく高速な包含のみのインデックスには opclass `jsonb_path_ops` を検討してください:
  - `CREATE INDEX ON tbl USING GIN (jsonb_col jsonb_path_ops);`
  - **トレードオフ**: キーの存在（`?`, `?|`, `?&`）クエリのサポートを失います。包含（`@>`）のみをサポートします。
- 特定のスカラーフィールドでの等価/範囲:抽出して B-tree でインデックスを作成します（生成列または式）:
  - `ALTER TABLE tbl ADD COLUMN price INT GENERATED ALWAYS AS ((jsonb_col->>'price')::INT) STORED;`
  - `CREATE INDEX ON tbl (price);`
  - インデックスなしの `WHERE (jsonb_col->>'price')::INT BETWEEN 100 AND 500` よりも `WHERE price BETWEEN 100 AND 500`（B-tree を使用）を推奨します。
- JSONB 内の配列: 包含（例: タグ）には GIN + `@>` を使用します。包含のみを行う場合は `jsonb_path_ops` を検討してください。
- コアリレーションはテーブルに保持します。オプション/可変属性には JSONB を使用します。
- 列内の許可される JSONB 値を制限するために制約を使用します。例: `config JSONB NOT NULL CHECK(jsonb_typeof(config) = 'object')`

## 例

### ユーザー (Users)

```sql
CREATE TABLE users (
  user_id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  email TEXT NOT NULL UNIQUE,
  name TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE UNIQUE INDEX ON users (LOWER(email));
CREATE INDEX ON users (created_at);
```

### 注文 (Orders)

```sql
CREATE TABLE orders (
  order_id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  user_id BIGINT NOT NULL REFERENCES users(user_id),
  status TEXT NOT NULL DEFAULT 'PENDING' CHECK (status IN ('PENDING','PAID','CANCELED')),
  total NUMERIC(10,2) NOT NULL CHECK (total > 0),
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE INDEX ON orders (user_id);
CREATE INDEX ON orders (created_at);
```

### JSONB

```sql
CREATE TABLE profiles (
  user_id BIGINT PRIMARY KEY REFERENCES users(user_id),
  attrs JSONB NOT NULL DEFAULT '{}',
  theme TEXT GENERATED ALWAYS AS (attrs->>'theme') STORED
);
CREATE INDEX profiles_attrs_gin ON profiles USING GIN (attrs);
```
